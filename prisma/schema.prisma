// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ========================================
// Enums
// ========================================

enum AccountStatus {
  ACTIVE
  BANNED
  SUSPENDED
  INACTIVE
  PENDING
}

enum ProxyType {
  RESIDENTIAL
  DATACENTER
  MOBILE
  ISP
}

enum ProxyStatus {
  ACTIVE
  DEAD
  SLOW
  UNKNOWN
}

enum PurchaseStatus {
  SUCCESS
  FAILED
  NEEDS_REVIEW
}

enum TicketStatus {
  PURCHASED
  LISTED
  SOLD
  CANCELLED
}

// ========================================
// IMAP Credentials - Store IMAP provider login info
// ========================================

model ImapCredential {
  id        String   @id @default(cuid())
  email     String   @unique // e.g., hoangconghai1602@gmail.com
  password  String   // App password
  provider  String   // "gmail", "outlook", "aycd", etc.
  isEnabled Boolean  @default(true) @map("is_enabled")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations - accounts using this IMAP credential
  accounts Account[]

  @@map("imap_credentials")
}

// ========================================
// Account Tags - For organizing/filtering accounts
// ========================================

model AccountTag {
  id        String   @id @default(cuid())
  name      String   @unique // e.g., "Eric", "Client-A"
  color     String?  // Optional hex color for UI display
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  accounts      Account[]
  generatorJobs GeneratorJob[]

  @@map("account_tags")
}

// ========================================
// Card Tags - For organizing/filtering cards
// ========================================

model CardTag {
  id        String   @id @default(cuid())
  name      String   @unique // e.g., "visa", "amex", "personal"
  color     String?  // Optional hex color for UI display
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  cards Card[]

  @@map("card_tags")
}

// ========================================
// Core Tables
// ========================================

model Account {
  id               String        @id @default(cuid())
  email            String        @unique
  password         String?
  phoneNumber      String?       @map("phone_number")
  imapProvider     String?       @map("imap_provider") // Legacy field for "aycd", "gmail" reference
  status           AccountStatus @default(ACTIVE)
  notes            String?
  createdAt        DateTime      @default(now()) @map("created_at")
  updatedAt        DateTime      @updatedAt @map("updated_at")

  // Generation metadata (when account was created by generator)
  generatedAt      DateTime?     @map("generated_at")       // When account was generated
  generatorJobId   String?       @map("generator_job_id")   // Link to job that created it
  generatorTaskId  String?       @map("generator_task_id")  // Link to specific task

  // POS/TicketVault account import metadata
  posAccountId        Int?       @unique @map("pos_account_id") // TicketVault CompanySeasonSiteID from purchase/account
  posImportedAt       DateTime?  @map("pos_imported_at")        // When account was imported to POS
  
  // POS/TicketVault sync metadata (from season sites)
  posSeasonSiteId     Int?       @map("pos_season_site_id")    // TicketVault CompanySeasonSiteID from settings
  posLastCheckedAt    DateTime?  @map("pos_last_checked_at")   // When TV last synced this account
  posSyncStatus       String?    @map("pos_sync_status")       // "Completed", "Error", "Processing"
  posLastError        String?    @map("pos_last_error")        // Last sync error message
  posTicketsFound     Int?       @map("pos_tickets_found")     // Tickets found in last sync
  posTicketsUpdated   Int?       @map("pos_tickets_updated")   // Tickets updated in last sync

  // Proxy relationships
  creationProxyId  String?       @map("creation_proxy_id")
  runtimeProxyId   String?       @map("runtime_proxy_id")
  
  // IMAP credential relationship
  imapCredentialId String?       @map("imap_credential_id")

  // Relations
  cards            Card[]          // One account can have multiple cards
  queuePositions   QueuePosition[]
  purchases        Purchase[]
  proxies          AccountProxy[]  // Legacy many-to-many relation
  creationProxy    Proxy?          @relation("CreationProxy", fields: [creationProxyId], references: [id], onDelete: SetNull)
  runtimeProxy     Proxy?          @relation("RuntimeProxy", fields: [runtimeProxyId], references: [id], onDelete: SetNull)
  imapCredential   ImapCredential? @relation(fields: [imapCredentialId], references: [id], onDelete: SetNull)
  tags             AccountTag[]    // Tags for organizing accounts
  checkoutJobs     CheckoutJob[]   // Checkout jobs for this account

  @@index([creationProxyId])
  @@index([runtimeProxyId])
  @@index([imapCredentialId])
  @@index([generatorJobId])
  @@map("accounts")
}

model Card {
  id             String    @id @default(cuid())
  accountId      String?   @map("account_id") // Optional - unlinked cards have null, not unique (many cards per account)
  profileName    String    @unique @map("profile_name") // Required and unique
  cardType       String    @map("card_type") // Visa, Mastercard, etc.
  cardNumber     String    @unique @map("card_number") // Unique card number
  expMonth       String    @map("exp_month")
  expYear        String    @map("exp_year")
  cvv            String
  billingName    String    @map("billing_name")
  billingPhone   String?   @map("billing_phone")
  billingAddress String    @map("billing_address")
  billingZip     String    @map("billing_zip")
  billingCity    String    @map("billing_city")
  billingState   String    @map("billing_state")
  deletedAt      DateTime? @map("deleted_at") // Soft delete - null means active
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")

  // Checkout tracking
  checkoutStatus String    @default("AVAILABLE") @map("checkout_status") // AVAILABLE, IN_USE, DECLINED, EXHAUSTED
  useCount       Int       @default(0) @map("use_count")
  lastUsedAt     DateTime? @map("last_used_at")

  // Relations
  account      Account?      @relation(fields: [accountId], references: [id], onDelete: SetNull)
  purchases    Purchase[]
  checkoutJobs CheckoutJob[]
  tags         CardTag[]     // Tags for organizing cards (e.g., "visa", "amex")

  @@index([accountId])
  @@index([checkoutStatus])
  @@map("cards")
}

model Proxy {
  id          String      @id @default(cuid())
  proxyString String      @unique @map("proxy_string") // ip:port:user:pass format
  type        ProxyType   @default(RESIDENTIAL)
  provider    String?     // e.g., "proxies" from the proxy string
  status      ProxyStatus @default(UNKNOWN)
  lastChecked DateTime?   @map("last_checked")
  notes       String?
  createdAt   DateTime    @default(now()) @map("created_at")
  updatedAt   DateTime    @updatedAt @map("updated_at")

  // Relations
  accounts        AccountProxy[]   // Legacy many-to-many
  createdAccounts Account[]        @relation("CreationProxy")
  runtimeAccounts Account[]        @relation("RuntimeProxy")

  @@map("proxies")
}

model AccountProxy {
  id         String   @id @default(cuid())
  accountId  String   @map("account_id")
  proxyId    String   @map("proxy_id")
  assignedAt DateTime @default(now()) @map("assigned_at")
  isActive   Boolean  @default(true) @map("is_active")
  usageType  String?  @map("usage_type") // "creation", "runtime", "both"

  // Relations
  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  proxy   Proxy   @relation(fields: [proxyId], references: [id], onDelete: Cascade)

  @@unique([accountId, proxyId])
  @@map("account_proxies")
}

model Event {
  id           String    @id @default(cuid())
  tmEventId    String    @unique @map("tm_event_id") // Ticketmaster event ID or generated hash
  artistName   String?   @map("artist_name") // Artist/performer name
  eventName    String    @map("event_name") // Show/tour name
  venue        String?
  venueId      String?   @map("venue_id") // Vivid Seats venue ID for linking to VenueMap
  eventDate    DateTime? @map("event_date")
  dayOfWeek    String?   @map("day_of_week") // "Mon", "Tue", "Wed", etc.
  eventDateRaw String?   @map("event_date_raw") // Original date string from source
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  
  // Get-in price from secondary market
  getInPrice          Decimal?  @map("get_in_price") @db.Decimal(10, 2)
  getInPriceUrl       String?   @map("get_in_price_url")
  getInPriceSource    String?   @map("get_in_price_source") // "vividseats", "stubhub"
  getInPriceUpdatedAt DateTime? @map("get_in_price_updated_at")
  
  // POS/TicketVault linking
  posProductionId     Int?      @unique @map("pos_production_id") // TicketVault ProductionID
  posVenueId          Int?      @map("pos_venue_id")              // TicketVault VenueID

  // Relations
  queuePositions QueuePosition[]
  purchases      Purchase[]
  tickets        Ticket[]
  listings       Listing[]
  sales          Sale[]
  zonePrices     EventZonePrice[]

  @@index([eventName])
  @@index([artistName])
  @@index([venueId])
  @@index([posProductionId])
  @@map("events")
}

model EventZonePrice {
  id        String   @id @default(cuid())
  eventId   String   @map("event_id")
  zoneName  String   @map("zone_name") // "Floor Seating", "Lower Level", "Upper Level", "Club Level"
  minPrice  Decimal  @map("min_price") @db.Decimal(10, 2)
  scrapedAt DateTime @map("scraped_at")
  colorHex  String?  @map("color_hex") // Zone color from Vivid Seats

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, zoneName])
  @@index([eventId])
  @@map("event_zone_prices")
}

// ========================================
// Venue Maps & Zone Mappings
// ========================================

model VenueMap {
  id            String   @id @default(cuid())
  venueId       String   @unique @map("venue_id") // Vivid Seats venue ID (e.g., "737")
  venueName     String   @map("venue_name")
  staticMapUrl  String?  @map("static_map_url")
  svgFileName   String?  @map("svg_file_name")
  jsonFileName  String?  @map("json_file_name")
  scrapedAt     DateTime @map("scraped_at")
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  // Relations
  zones VenueZone[]

  @@map("venue_maps")
}

model VenueZone {
  id           String   @id @default(cuid())
  venueMapId   String   @map("venue_map_id")
  zoneName     String   @map("zone_name")
  colorHex     String?  @map("color_hex")
  displayOrder Int?     @map("display_order")
  createdAt    DateTime @default(now()) @map("created_at")
  updatedAt    DateTime @updatedAt @map("updated_at")

  // Relations
  venueMap VenueMap           @relation(fields: [venueMapId], references: [id], onDelete: Cascade)
  sections VenueSectionZone[]

  @@unique([venueMapId, zoneName])
  @@index([venueMapId])
  @@map("venue_zones")
}

model VenueSectionZone {
  id          String   @id @default(cuid())
  venueZoneId String   @map("venue_zone_id")
  sectionName String   @map("section_name") // e.g., "Promenade V1"
  minPrice    Decimal? @map("min_price") @db.Decimal(10, 2) // Section-specific min price
  createdAt   DateTime @default(now()) @map("created_at")

  // Relations
  venueZone VenueZone @relation(fields: [venueZoneId], references: [id], onDelete: Cascade)

  @@unique([venueZoneId, sectionName])
  @@index([sectionName])
  @@index([venueZoneId])
  @@map("venue_section_zones")
}

model QueuePosition {
  id        String   @id @default(cuid())
  accountId String   @map("account_id")
  eventId   String   @map("event_id")
  position  Int      // Queue position number
  testedAt  DateTime @default(now()) @map("tested_at")
  source    String?  // Which encore run, batch identifier, etc.
  notes     String?
  
  // Calculated fields (stored for performance)
  percentile        Int?    // Percentile ranking (0-100), calculated when imported
  totalParticipants Int?    @map("total_participants") // Total participants at time of calculation
  
  // Exclusion fields for outlier filtering
  excluded       Boolean   @default(false) // If true, don't include in calculations
  excludedAt     DateTime? @map("excluded_at") // When it was excluded
  excludedReason String?   @map("excluded_reason") // Why it was excluded (e.g., "late entry", "outlier")

  // Relations
  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)
  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)

  // Unique constraint for deduplication - one position per account per event
  @@unique([accountId, eventId])
  @@index([accountId])
  @@index([eventId])
  @@index([testedAt])
  @@index([excluded])
  @@map("queue_positions")
}

model Purchase {
  id              String         @id @default(cuid())
  accountId       String         @map("account_id")
  eventId         String?        @map("event_id")
  cardId          String?        @map("card_id")

  // Job details from tm-checkout
  externalJobId   String?        @unique @map("external_job_id")
  tmOrderNumber   String?        @unique @map("tm_order_number") // Ticketmaster order number for deduplication
  status          PurchaseStatus
  errorCode       String?        @map("error_code")
  errorMessage    String?        @map("error_message")

  // Card info from import (for re-linking purposes)
  cardLast4       String?        @map("card_last_4")

  // Ticket details
  quantity        Int            @default(1)
  priceEach       Decimal?       @map("price_each") @db.Decimal(10, 2)
  totalPrice      Decimal?       @map("total_price") @db.Decimal(10, 2)
  section         String?
  row             String?
  seats           String?        // e.g., "12-17" or "5,6,7"

  // Price comparison override (for profit calculations)
  priceOverrideType  String?   @map("price_override_type")  // "get_in", "zone", "manual"
  priceOverrideZone  String?   @map("price_override_zone")  // Zone name if using zone price
  priceOverrideValue Decimal?  @map("price_override_value") @db.Decimal(10, 2) // Manual price

  // Dashboard PO tracking
  dashboardPoNumber  String?   @unique @map("dashboard_po_number") // 6-digit: "000001"

  // TicketVault POS sync fields
  posSyncedAt        DateTime? @map("pos_synced_at")
  posTicketGroupId   Int?      @map("pos_ticket_group_id")
  posPurchaseOrderId Int?      @map("pos_purchase_order_id")
  posEventId         Int?      @map("pos_event_id")

  // URLs
  checkoutUrl     String?        @map("checkout_url")
  confirmationUrl String?        @map("confirmation_url")

  // Timestamps
  createdAt       DateTime       @default(now()) @map("created_at")
  startedAt       DateTime?      @map("started_at")
  completedAt     DateTime?      @map("completed_at")
  attemptCount    Int            @default(1) @map("attempt_count")

  // Relations
  account  Account   @relation(fields: [accountId], references: [id], onDelete: Cascade)
  event    Event?    @relation(fields: [eventId], references: [id], onDelete: SetNull)
  card     Card?     @relation(fields: [cardId], references: [id], onDelete: SetNull)
  listings Listing[] // POS listings linked to this purchase
  tickets  Ticket[]  // Individual tickets from this purchase

  @@index([accountId])
  @@index([eventId])
  @@index([status])
  @@index([createdAt])
  @@index([errorCode])
  @@map("purchases")
}

model Setting {
  id        String   @id @default(cuid())
  key       String   @unique // e.g., "marketplace_fee_percentage"
  value     String   // Store as string, parse as needed
  updatedAt DateTime @updatedAt @map("updated_at")
  createdAt DateTime @default(now()) @map("created_at")

  @@map("settings")
}

// ========================================
// POS Listings - Cached from TicketVault
// ========================================

model Listing {
  id                 String    @id @default(cuid())
  
  // TicketVault IDs
  ticketGroupId      Int       @unique @map("ticket_group_id")
  purchaseOrderId    Int?      @map("purchase_order_id")
  
  // Event info
  eventName          String    @map("event_name")
  venueName          String?   @map("venue_name")
  venueCity          String?   @map("venue_city")
  eventDateTime      DateTime? @map("event_date_time")
  
  // Ticket details
  section            String
  row                String
  startSeat          Int       @map("start_seat")
  endSeat            Int       @map("end_seat")
  quantity           Int
  
  // Pricing
  cost               Decimal   @map("cost") @db.Decimal(10, 2)
  price              Decimal   @map("price") @db.Decimal(10, 2)
  
  // Account info
  accountEmail       String?   @map("account_email")
  internalNote       String?   @map("internal_note")
  extPONumber        String?   @map("ext_po_number")
  
  // Match status
  isMatched          Boolean   @default(false) @map("is_matched")
  barcodesCount      Int       @default(0) @map("barcodes_count")
  pdfsCount          Int       @default(0) @map("pdfs_count")
  linksCount         Int       @default(0) @map("links_count")
  pdfStatus          String?   @map("pdf_status")
  
  // Listing status
  statusTypeId       Int?      @map("status_type_id")
  poVendor           String?   @map("po_vendor")
  
  // Marketplace IDs (for links)
  vividEventId       Int?      @map("vivid_event_id")
  stubhubEventId     Int?      @map("stubhub_event_id")
  seatgeekEventId    Int?      @map("seatgeek_event_id")
  tmEventId          String?   @map("tm_event_id")
  productionId       Int?      @map("production_id")
  
  // Sync tracking
  lastSyncedAt       DateTime  @map("last_synced_at")
  createdAt          DateTime  @default(now()) @map("created_at")
  updatedAt          DateTime  @updatedAt @map("updated_at")
  
  // Link to our Purchase if exists (by extPONumber match)
  purchaseId         String?   @map("purchase_id")
  purchase           Purchase? @relation(fields: [purchaseId], references: [id], onDelete: SetNull)
  
  // Link to normalized Event
  eventId            String?   @map("event_id")
  event              Event?    @relation(fields: [eventId], references: [id], onDelete: SetNull)
  
  // Sales from this listing
  sales              Sale[]
  
  // Individual tickets in this listing
  tickets            Ticket[]
  
  @@index([accountEmail])
  @@index([extPONumber])
  @@index([isMatched])
  @@index([eventDateTime])
  @@index([purchaseId])
  @@index([eventId])
  @@map("listings")
}

// ========================================
// Sales & Invoices - From TicketVault
// ========================================
//
// IMPORTANT: Data Model & Profit Calculation
// ------------------------------------------
// 
// Hierarchy: Purchase -> Listing -> Sale -> Invoice
//
// KEY RELATIONSHIPS:
// - One Invoice can have MULTIPLE Sales (e.g., buyer purchases from 2 listings = 1 invoice, 2 sales)
// - One Sale belongs to exactly ONE Invoice
// - One Listing can have MULTIPLE Sales (partial quantity sales)
// - One Purchase can have MULTIPLE Listings (resold on different platforms)
//
// PROFIT CALCULATION - ALWAYS USE INVOICES:
// -----------------------------------------
// Total Profit = Sum(invoice.totalAmount) - Sum(invoice.totalCost)
//
// - invoice.totalAmount = Net payout from TicketVault (AFTER their fees are deducted)
// - invoice.totalCost = Our purchase cost (synced from TicketVault)
//
// WARNING: DO NOT calculate profit from Sales by summing sale.salePrice!
// sale.salePrice is the GROSS amount for that sale (before fees).
// If you try to estimate fees per-sale and there are multiple sales per invoice,
// you'll get calculation errors. Always aggregate at the invoice level.
//
// ========================================

model Sale {
  id                String    @id @default(cuid())
  
  // TicketVault IDs
  ticketGroupId     Int       @map("ticket_group_id")      // Links to Listing
  invoiceNumber     Int?      @map("invoice_number")       // Links to Invoice
  orderId           Int?      @map("order_id")             // TV Order ID
  
  // Event info (denormalized for display)
  eventName         String?   @map("event_name")
  eventDateTime     DateTime? @map("event_date_time")
  venueName         String?   @map("venue_name")
  
  // Ticket details
  section           String?
  row               String?
  seats             String?                                 // e.g., "1-2" or "5,6"
  quantity          Int                                     // Tickets sold in this sale
  
  // Pricing
  // NOTE: salePrice is GROSS (before fees). Do NOT use for profit calculation!
  // Use invoice.totalAmount instead which is net after TicketVault fees.
  salePrice         Decimal   @map("sale_price") @db.Decimal(10, 2) // GROSS - before marketplace fees
  cost              Decimal?  @map("cost") @db.Decimal(10, 2)       // PER-TICKET cost (multiply by quantity for total)
  
  // Buyer info
  buyerEmail        String?   @map("buyer_email")
  buyerName         String?   @map("buyer_name")
  
  // Status (from salesQueue Status field)
  status            Int       @default(0)                   // 20=Pending, 40=Complete, etc.
  statusName        String?   @map("status_name")
  deliveryType      String?   @map("delivery_type")
  transferType      String?   @map("transfer_type")
  
  // Fulfillment tracking
  isComplete        Boolean   @default(false) @map("is_complete")
  needsShipping     Boolean   @default(false) @map("needs_shipping")
  mobileInfoNeeded  Boolean   @default(false) @map("mobile_info_needed")
  pdfBcMissing      Boolean   @default(false) @map("pdf_bc_missing")
  
  // External order number (marketplace order)
  extOrderNumber    String?   @map("ext_order_number")
  
  // Our PO number (from TicketVault ExtPONumber field)
  extPONumber       String?   @map("ext_po_number")
  
  // Timestamps
  saleDate          DateTime? @map("sale_date")
  lastSyncedAt      DateTime  @map("last_synced_at")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")
  
  // Relations
  listingId         String?   @map("listing_id")
  listing           Listing?  @relation(fields: [listingId], references: [id], onDelete: SetNull)
  invoice           Invoice?  @relation(fields: [invoiceNumber], references: [invoiceNumber])
  
  // Link to normalized Event
  eventId           String?   @map("event_id")
  event             Event?    @relation(fields: [eventId], references: [id], onDelete: SetNull)
  
  // Individual tickets sold in this sale
  tickets           Ticket[]
  
  @@unique([ticketGroupId, orderId])
  @@index([listingId])
  @@index([invoiceNumber])
  @@index([status])
  @@index([saleDate])
  @@index([eventId])
  @@map("sales")
}

// Invoice - The SOURCE OF TRUTH for profit calculations
// 
// Each Invoice represents a complete transaction with a buyer.
// An Invoice may contain MULTIPLE Sales (if buyer purchased from multiple listings).
//
// PROFIT FORMULA: Sum(totalAmount) - Sum(totalCost)
// This matches exactly what you see in TicketVault when summing invoices.
model Invoice {
  id                String    @id @default(cuid())
  
  // TicketVault IDs
  invoiceNumber     Int       @unique @map("invoice_number")
  clientId          Int?      @map("client_id")
  
  // Client/Buyer info
  clientName        String?   @map("client_name")
  clientEmail       String?   @map("client_email")
  
  // Event info (denormalized from first sale)
  eventName         String?   @map("event_name")
  eventDateTime     DateTime? @map("event_date_time")
  
  // Ticket summary
  totalQuantity     Int       @default(0) @map("total_quantity")
  
  // ========================================
  // FINANCIAL FIELDS - Use these for profit!
  // ========================================
  // totalAmount: NET payout after TicketVault fees (from TV "Payout" field)
  //              This is what you actually receive.
  // fees:        TicketVault's marketplace fee amount
  // totalCost:   Our purchase cost (what we paid for the tickets)
  //
  // PROFIT = totalAmount - totalCost
  // ========================================
  totalAmount       Decimal   @map("total_amount") @db.Decimal(10, 2)  // NET payout (after fees)
  fees              Decimal   @default(0) @map("fees") @db.Decimal(10, 2)
  totalCost         Decimal   @default(0) @map("total_cost") @db.Decimal(10, 2) // Our purchase cost
  
  // Payment/Payout status
  isPaid            Boolean   @default(false) @map("is_paid")
  payoutStatus      String?   @map("payout_status")         // "Pending", "Paid", etc.
  remittanceStatus  String?   @map("remittance_status")
  remittanceDate    DateTime? @map("remittance_date")
  
  // Status
  isCancelled       Boolean   @default(false) @map("is_cancelled")
  
  // External PO Number (links to our purchase)
  extPONumber       String?   @map("ext_po_number")
  
  // Timestamps
  invoiceDate       DateTime? @map("invoice_date")
  lastSyncedAt      DateTime  @map("last_synced_at")
  createdAt         DateTime  @default(now()) @map("created_at")
  updatedAt         DateTime  @updatedAt @map("updated_at")
  
  // Relations
  sales             Sale[]
  
  @@index([isPaid])
  @@index([payoutStatus])
  @@index([invoiceDate])
  @@index([extPONumber])
  @@map("invoices")
}

// ========================================
// Tickets - Individual seat tracking
// ========================================

model Ticket {
  id              String       @id @default(cuid())
  
  // Links to parent records
  purchaseId      String       @map("purchase_id")
  eventId         String       @map("event_id")
  
  // Seat identity (unique per event)
  section         String
  row             String
  seatNumber      Int          @map("seat_number")
  
  // Cost (from purchase, per ticket)
  cost            Decimal      @db.Decimal(10, 2)
  
  // Lifecycle tracking
  listingId       String?      @map("listing_id")   // Set when listed on POS
  saleId          String?      @map("sale_id")      // Set when sold
  
  // Status
  status          TicketStatus @default(PURCHASED)
  
  // Timestamps
  createdAt       DateTime     @default(now()) @map("created_at")
  updatedAt       DateTime     @updatedAt @map("updated_at")
  
  // Relations
  purchase        Purchase     @relation(fields: [purchaseId], references: [id], onDelete: Cascade)
  event           Event        @relation(fields: [eventId], references: [id], onDelete: Cascade)
  listing         Listing?     @relation(fields: [listingId], references: [id], onDelete: SetNull)
  sale            Sale?        @relation(fields: [saleId], references: [id], onDelete: SetNull)
  
  @@unique([eventId, section, row, seatNumber])
  @@index([purchaseId])
  @@index([eventId])
  @@index([listingId])
  @@index([saleId])
  @@index([status])
  @@map("tickets")
}

// ========================================
// Generator Jobs - Remote account generation
// ========================================

model GeneratorJob {
  id           String    @id @default(cuid())
  status       String    @default("PENDING") // PENDING, RUNNING, COMPLETED, FAILED, CANCELLED
  threadCount  Int       @default(1) @map("thread_count")

  // Tag to apply to generated accounts
  tagId        String?   @map("tag_id")

  // IMAP provider for this job
  imapProvider String    @default("aycd") @map("imap_provider") // "aycd" or "gmail"

  // Auto-import successful accounts immediately
  autoImport   Boolean   @default(false) @map("auto_import")

  // Progress tracking
  totalTasks   Int       @default(0) @map("total_tasks")
  completed    Int       @default(0)
  succeeded    Int       @default(0)
  failed       Int       @default(0)

  // Worker info
  workerId     String?   @map("worker_id") // Which VPS claimed this
  startedAt    DateTime? @map("started_at")
  completedAt  DateTime? @map("completed_at")

  // Timestamps
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  // Relations
  tasks        GeneratorTask[]
  tag          AccountTag?     @relation(fields: [tagId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([createdAt])
  @@index([tagId])
  @@map("generator_jobs")
}

model GeneratorTask {
  id           String    @id @default(cuid())
  jobId        String    @map("job_id")

  // Input
  email        String
  imapSource   String    @map("imap_source") // "aycd" or gmail address
  proxy        String?

  // Status
  status       String    @default("PENDING") // PENDING, RUNNING, SUCCESS, FAILED
  errorMessage String?   @map("error_message")

  // Output (on success)
  password     String?
  phoneNumber  String?   @map("phone_number")
  firstName    String?   @map("first_name")
  lastName     String?   @map("last_name")
  postalCode   String?   @map("postal_code")

  // Import status (for manual import workflow)
  imported     Boolean   @default(false)
  importedAt   DateTime? @map("imported_at")

  // Timing
  startedAt    DateTime? @map("started_at")
  completedAt  DateTime? @map("completed_at")

  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")

  // Relations
  job          GeneratorJob @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([status])
  @@index([imported])
  @@map("generator_tasks")
}

model GeneratorConfig {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String   // JSON string for complex values
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("generator_config")
}

// ========================================
// Generator Pools - Email and Proxy Management
// ========================================

model GeneratorEmail {
  id        String    @id @default(cuid())
  email     String    @unique
  status    String    @default("AVAILABLE") // AVAILABLE, IN_USE, USED
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  @@index([status])
  @@index([createdAt])
  @@map("generator_emails")
}

model GeneratorProxy {
  id         String    @id @default(cuid())
  proxy      String    @unique
  status     String    @default("AVAILABLE") // AVAILABLE, IN_USE, BAD
  useCount   Int       @default(0) @map("use_count")
  lastUsedAt DateTime? @map("last_used_at")
  createdAt  DateTime  @default(now()) @map("created_at")

  @@index([status])
  @@index([useCount])
  @@map("generator_proxies")
}

model GeneratorBadProxy {
  id         String   @id @default(cuid())
  proxy      String
  reason     String?
  jobId      String?  @map("job_id")
  detectedAt DateTime @default(now()) @map("detected_at")

  @@index([detectedAt])
  @@map("generator_bad_proxies")
}

// ========================================
// Checkout System - TM Checkout Integration
// ========================================

model CheckoutJob {
  id            String    @id @default(cuid())
  discordMsgId  String?   @map("discord_msg_id")
  targetUrl     String    @map("target_url")
  
  // Status
  status        String    @default("QUEUED") // QUEUED, RUNNING, SUCCESS, FAILED, NEEDS_REVIEW, CANCELLED
  workerId      String?   @map("worker_id")
  attemptCount  Int       @default(0) @map("attempt_count")
  priority      Int       @default(0) // Higher = processed first (for priority retries)
  
  // Timing
  createdAt     DateTime  @default(now()) @map("created_at")
  startedAt     DateTime? @map("started_at")
  completedAt   DateTime? @map("completed_at")
  expiresAt     Int?      @map("expires_at") // Unix timestamp
  
  // Event info (denormalized from Discord webhook)
  eventName     String?   @map("event_name")
  tmEventId     String?   @map("tm_event_id") // Ticketmaster event ID
  venue         String?
  eventDate     String?   @map("event_date")
  section       String?
  row           String?
  seats         String?
  quantity      Int       @default(1)
  priceEach     Decimal?  @map("price_each") @db.Decimal(10, 2)
  totalPrice    Decimal?  @map("total_price") @db.Decimal(10, 2)
  currency      String?   // USD or CAD
  
  // Account/Card linking
  accountId     String?   @map("account_id")
  cardId        String?   @map("card_id")
  accountEmail  String?   @map("account_email")
  cardLast4     String?   @map("card_last_4")
  
  // Outcome
  finalUrl      String?   @map("final_url")
  errorCode     String?   @map("error_code")
  errorMessage  String?   @map("error_message")
  tmOrderNumber String?   @map("tm_order_number")
  
  // Import tracking
  imported      Boolean   @default(false)
  importedAt    DateTime? @map("imported_at")
  purchaseId    String?   @map("purchase_id")
  
  // Run tracking
  runId         String?   @map("run_id")
  
  // Relations
  account       Account?  @relation(fields: [accountId], references: [id], onDelete: SetNull)
  card          Card?     @relation(fields: [cardId], references: [id], onDelete: SetNull)
  run           CheckoutRun? @relation(fields: [runId], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([accountId])
  @@index([cardId])
  @@index([runId])
  @@index([createdAt])
  @@index([imported])
  @@map("checkout_jobs")
}

model CheckoutRun {
  id           String    @id @default(cuid())
  workerId     String    @map("worker_id")
  status       String    @default("RUNNING") // RUNNING, COMPLETED, ABORTED
  
  // Timing
  startedAt    DateTime  @default(now()) @map("started_at")
  endedAt      DateTime? @map("ended_at")
  lastHeartbeat DateTime? @map("last_heartbeat") // Updated by daemon every 10s to indicate liveness
  
  // Worker count - how many parallel workers are running in this daemon
  activeWorkerCount Int   @default(1) @map("active_worker_count")
  
  // Stats
  jobsQueued   Int       @default(0) @map("jobs_queued")
  jobsSuccess  Int       @default(0) @map("jobs_success")
  jobsFailed   Int       @default(0) @map("jobs_failed")
  jobsReview   Int       @default(0) @map("jobs_review")
  
  notes        String?
  
  // Relations
  jobs         CheckoutJob[]
  workers      CheckoutWorker[]

  @@index([workerId])
  @@index([startedAt])
  @@map("checkout_runs")
}

model CheckoutWorker {
  id            String    @id @default(cuid())
  runId         String    @map("run_id")
  workerName    String    @map("worker_name")   // e.g., "local-dev-1"
  deviceName    String    @map("device_name")   // e.g., "local-dev" (parent daemon)
  status        String    @default("IDLE")      // IDLE, PROCESSING, PAUSED, STOPPED
  
  currentJobId  String?   @map("current_job_id")
  currentEvent  String?   @map("current_event") // Event name for display
  
  lastHeartbeat DateTime  @default(now()) @map("last_heartbeat")
  startedAt     DateTime  @default(now()) @map("started_at")
  stoppedAt     DateTime? @map("stopped_at")
  
  jobsCompleted Int       @default(0) @map("jobs_completed")
  jobsFailed    Int       @default(0) @map("jobs_failed")
  
  run           CheckoutRun @relation(fields: [runId], references: [id], onDelete: Cascade)
  
  @@index([runId])
  @@index([status])
  @@index([lastHeartbeat])
  @@map("checkout_workers")
}

model CheckoutConfig {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String   // JSON string for complex values
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("checkout_config")
}

// =============================================================================
// Scrape Service (VPS-based web scraping)
// =============================================================================

enum ScrapeJobType {
  TICKETMASTER_EVENT
  VIVID_SEATS_PRICE
}

enum ScrapeJobStatus {
  QUEUED
  RUNNING
  SUCCESS
  FAILED
}

model ScrapeJob {
  id          String          @id @default(cuid())
  type        ScrapeJobType   // What kind of scrape
  status      ScrapeJobStatus @default(QUEUED)
  
  // Input data (JSON)
  inputData   String          @map("input_data") @db.Text // JSON: { eventId, artistName, venue, date, url, etc. }
  
  // Output data (JSON) - populated when complete
  outputData  String?         @map("output_data") @db.Text // JSON: scraped result
  
  // Error info
  errorCode   String?         @map("error_code")
  errorMessage String?        @map("error_message")
  
  // Tracking
  workerId    String?         @map("worker_id")
  runId       String?         @map("run_id")
  
  createdAt   DateTime        @default(now()) @map("created_at")
  startedAt   DateTime?       @map("started_at")
  completedAt DateTime?       @map("completed_at")
  
  // Relations
  run         ScrapeRun?      @relation(fields: [runId], references: [id])

  @@index([status])
  @@index([type])
  @@index([createdAt])
  @@map("scrape_jobs")
}

model ScrapeRun {
  id            String    @id @default(cuid())
  workerId      String    @map("worker_id") // Machine identifier
  status        String    @default("RUNNING") // RUNNING, COMPLETED, ABORTED
  
  startedAt     DateTime  @default(now()) @map("started_at")
  endedAt       DateTime? @map("ended_at")
  lastHeartbeat DateTime  @default(now()) @map("last_heartbeat")
  
  // Stats
  jobsSuccess   Int       @default(0) @map("jobs_success")
  jobsFailed    Int       @default(0) @map("jobs_failed")
  
  // Relations
  jobs          ScrapeJob[]

  @@index([workerId])
  @@index([status])
  @@index([lastHeartbeat])
  @@map("scrape_runs")
}

model ScrapeConfig {
  id        String   @id @default(cuid())
  key       String   @unique
  value     String   // JSON string for complex values
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("scrape_config")
}
